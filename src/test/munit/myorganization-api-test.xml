<?xml version="1.0" encoding="UTF-8"?>
<mule xmlns:core="http://www.mulesoft.org/schema/mule/core" xmlns="http://www.mulesoft.org/schema/mule/core" xmlns:doc="http://www.mulesoft.org/schema/mule/documentation" xmlns:http="http://www.mulesoft.org/schema/mule/http" xmlns:mock="http://www.mulesoft.org/schema/mule/mock" xmlns:munit="http://www.mulesoft.org/schema/mule/munit" xmlns:spring="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mulesoft.org/schema/mule/core http://www.mulesoft.org/schema/mule/core/current/mule.xsd
http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd
http://www.mulesoft.org/schema/mule/http http://www.mulesoft.org/schema/mule/http/current/mule-http.xsd
http://www.mulesoft.org/schema/mule/munit http://www.mulesoft.org/schema/mule/munit/current/mule-munit.xsd
http://www.mulesoft.org/schema/mule/mock http://www.mulesoft.org/schema/mule/mock/current/mule-mock.xsd">
	<spring:beans>
		<spring:import resource="classpath:api.xml" />
	</spring:beans>
	<munit:config mock-connectors="false" mock-inbounds="false" doc:name="MUnit configuration" />
	<http:request-config name="HTTP_Request_Configuration" host="localhost" port="8081" basePath="/api" doc:name="HTTP Request Configuration" />

	<!-- Testing the Resource Not Found (HTTP 404) response error from API Kit. -->
	<munit:test name="resourceNotFound404Test" description="Verifying functionality of [resourceNotFound404Test]">

		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customersincorrectresource" doc:name="HTTP">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="404" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(404))]" doc:name="assert that - http.status eq 404" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/resourceNotFound.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- Testing the Method Not Allowed (HTTP 405) response error from API Kit. -->
	<munit:test name="methodNotAllowed405Test" description="Verifying functionality of [methodNotAllowed405Test]">

		<http:request config-ref="HTTP_Request_Configuration" method="PATCH" path="/customers" doc:name="HTTP">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="405" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(405))]" doc:name="assert that - http.status eq 405" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/methodNotAllowed.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- Testing the Not Acceptable (HTTP 406) response error from API Kit. -->
	<munit:test name="notAcceptable406Test" description="Verifying functionality of [notAcceptable406Test]">

		<!-- Set the request JSON payload -->
		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/post_customers.json').asString()]" doc:name="Set Payload" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="POST" path="/customers" doc:name="POST HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/xml" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="406" />
		</http:request>

		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(406))]" doc:name="assert that - http.status eq 406" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/notAcceptableHTTP.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- UNIT TESTS FOR CUSTOMER RESOURCE -->
	<!-- /GET: CUSTOMERS TESTS -->

	<!-- /GET CUSTOMER TEST Description: Validating the /GET CUSTOMER resource for the HTTP 200 Response. -->
	<munit:test name="/GET:customers-HTTP-200-Test" description="Verifying functionality of [/GET:customers-HTTP-200-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
        <!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for retrieveCustomers subflow output of customerResult property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Retrieve Customers Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('retrieveCustomers')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerResult" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customers" doc:name="GET HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />

		<logger message="Response: #[message]" level="INFO" doc:name="Logger" />

		<!-- Begin Assertions -->
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(200))]" doc:name="assert that - http.status eq 200" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/get_200_customers.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>


	<!-- /GET CUSTOMER TEST Description: Validating the /GET CUSTOMER resource for the HTTP 401 Response. -->
	<munit:test name="/GET:customers-HTTP-401-Test" description="Verifying functionality of [/GET:customers-HTTP-401-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<!-- Setting this to false should trigger a HTTP 401 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="false" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customers" doc:name="GET HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="401" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />

		<logger message="Response: #[payload]" level="INFO" doc:name="Logger" />

		<!-- Begin Assertions -->
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(401))]" doc:name="assert that - http.status eq 401" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/get_401_customers.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>


	<!-- /GET CUSTOMER TEST Description: Validating the /GET CUSTOMER resource for the HTTP 404 Response. -->
	<munit:test name="/GET:customers-HTTP-404-Test" description="Verifying functionality of [/GET:customers-HTTP-404-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for retrieveCustomers subflow output of customerResult property -->
		<!-- Setting the customerResult to empty should trigger a HTTP 404 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Retrieve Customers Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('retrieveCustomers')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerResult" value="#[]" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customers" doc:name="GET HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="404" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />

		<logger message="Response: #[payload]" level="INFO" doc:name="Logger" />

		<!-- Begin Assertions -->
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(404))]" doc:name="assert that - http.status eq 404" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/get_404_customers.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- /GET CUSTOMER TEST Description: Validating the /GET CUSTOMER resource for the HTTP 404 Response. -->
	<munit:test name="/GET:customers-HTTP-500-Test" description="Verifying functionality of [/GET:customers-HTTP-500-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for retrieveCustomers subflow output of customerResult property -->
		<!-- Setting the payload to 'EXCEPTION' should trigger a HTTP 500 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Retrieve Customers Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('retrieveCustomers')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[('EXCEPTION')]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerResult" value="#[]" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customers" doc:name="GET HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="500" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />

		<logger message="Response: #[payload]" level="INFO" doc:name="Logger" />

		<!-- Begin Assertions -->
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(500))]" doc:name="assert that - http.status eq 500" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/get_500_customers.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>


	<!-- ========================================== -->
	<!-- /POST: CUSTOMERS TESTS -->
	<!-- ========================================== -->

	<!-- /POST CUSTOMER TEST Description: Validating the /POST CUSTOMER resource for the HTTP 201 Response. -->
	<munit:test name="/POST:customers-HTTP-201-Test" description="Verifying functionality of [/POST:customers-HTTP-201-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for createNewCustomer subflow output of newCustomerRecord property -->
		<!-- Setting the payload to 'EXCEPTION' should trigger a HTTP 500 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Retrieve Customers Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('createNewCustomer')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="newCustomerRecord" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<!-- Set the request JSON payload -->
		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/post_customers.json').asString()]" doc:name="Set Payload" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="POST" path="/customers" doc:name="POST HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />

		<logger message="Response: #[payload]" level="INFO" doc:name="Logger" />

		<!-- Begin Assertions -->
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(201))]" doc:name="assert that - http.status eq 201" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/post_201_customers.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- /POST CUSTOMER TEST Description: Validating the /POST CUSTOMER resource for the HTTP 400 Response. -->
	<munit:test name="/POST:customers-HTTP-400-Test" description="Verifying functionality of [/POST:customers-HTTP-400-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[payload]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<!-- Setting this to false should trigger an HTTP 400 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="false" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/post_customers_invalid.json').asString()]" doc:name="Set Payload" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="POST" path="/customers" doc:name="POST HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="400" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(400))]" doc:name="assert that - http.status eq 400" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/post_400_customers.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>


	<!-- /POST CUSTOMER TEST Description: Validating the /POST CUSTOMER resource for the HTTP 401 Response. -->
	<munit:test name="/POST:customers-HTTP-401-Test" description="Verifying functionality of [/POST:customers-HTTP-401-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<!-- Setting the validToken to false should trigger an HTTP 401 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="false" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/post_customers.json').asString()]" doc:name="Set Payload" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="POST" path="/customers" doc:name="POST HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="401" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(401))]" doc:name="assert that - http.status eq 401" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/post_401_customers.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>



	<!-- /POST CUSTOMER TEST Description: Validating the /POST CUSTOMER resource for the HTTP 500 Response. -->
	<munit:test name="/POST:customers-HTTP-500-Test" description="Verifying functionality of [/POST:customers-HTTP-500-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for createNewCustomer subflow output of newCustomerRecord property -->
		<!-- Setting the payload to 'EXCEPTION' should trigger a HTTP 500 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Retrieve Customers Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('createNewCustomer')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[('EXCEPTION')]">
				<mock:invocation-properties>
					<mock:invocation-property key="newCustomerRecord" value="#[]" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/post_customers.json').asString()]" doc:name="Set Payload" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="POST" path="/customers" doc:name="POST HTTP Request">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="500" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(500))]" doc:name="assert that - http.status eq 500" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/post_500_customers.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>


	<!-- ========================================== -->
	<!-- /GET: CUSTOMERS/{CUSTOMERID} TESTS -->
	<!-- ========================================== -->

	<!-- /GET CUSTOMER/{CUSTOMERID} TEST Description: Validating the /GET CUSTOMER/{CUSTOMERID} resource for the HTTP 200 Response. -->
	<munit:test name="/GET:customers/customerId-HTTP-200-Test" description="Verifying functionality of [/GET:customers/customerId-HTTP-200-Test]">


		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for retrieveCustomerRecord subflow output of customerRecord property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Retrieve Customer Record Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('retrieveCustomerRecord')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerRecord" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-variable variableName="customerId" value="333" doc:name="customerId" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customers/#[flowVars['customerId']]" doc:name="GET HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(200))]" doc:name="assert that - http.status eq 200" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/get_200_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />

	</munit:test>


	<!-- /GET CUSTOMER/{CUSTOMERID} TEST Description: Validating the /GET CUSTOMER/{CUSTOMERID} resource for the HTTP 401 Response. -->
	<munit:test name="/GET:customers/customerId-HTTP-401-Test" description="Verifying functionality of [/GET:customers/customerId-HTTP-401-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<!-- Setting the validToken property to false should trigger a HTTP 401 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="false" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-variable variableName="customerId" value="333" doc:name="customerId" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customers/#[flowVars['customerId']]" doc:name="GET HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="401" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(401))]" doc:name="assert that - http.status eq 401" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/get_401_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- /GET CUSTOMER/{CUSTOMERID} TEST Description: Validating the /GET CUSTOMER/{CUSTOMERID} resource for the HTTP 404 Response. -->
	<munit:test name="/GET:customers/customerId-HTTP-404-Test" description="Verifying functionality of [/GET:customers/customerId-HTTP-404-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for retrieveCustomerRecord subflow output of customerRecord property -->
		<!-- Setting the customerRecord as empty should trigger an HTTP 404 response -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Retrieve Customer Record Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('retrieveCustomerRecord')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerRecord" value="#[]" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-variable variableName="customerId" value="333" doc:name="customerId" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customers/#[flowVars['customerId']]" doc:name="GET HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="404" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(404))]" doc:name="assert that - http.status eq 404" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/get_404_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>


	<!-- /GET CUSTOMER/{CUSTOMERID} TEST Description: Validating the /GET CUSTOMER/{CUSTOMERID} resource for the HTTP 500 Response. -->
	<munit:test name="/GET:customers/customerId-HTTP-500-Test" description="Verifying functionality of [/GET:customers/customerId-HTTP-500-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for retrieveCustomerRecord subflow output of customerRecord property -->
		<!-- Setting the customerRecord as 'EXCEPTION' should trigger an HTTP 500 response -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Retrieve Customer Record Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('retrieveCustomerRecord')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[('EXCEPTION')]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerRecord" value="#[]" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-variable variableName="customerId" value="333" doc:name="customerId" />

		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="GET" path="/customers/#[flowVars['customerId']]" doc:name="GET HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="500" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(500))]" doc:name="assert that - http.status eq 500" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/get_500_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>


	<!-- ========================================== -->
	<!-- /PUT: CUSTOMERS/{CUSTOMERID} TESTS -->
	<!-- ========================================== -->

	<!-- /PUT CUSTOMER/{CUSTOMERID} TEST Description: Validating the /PUT CUSTOMER/{CUSTOMERID} resource for the HTTP 200 Response. -->
	<munit:test name="/PUT:customers/customerId-HTTP-200-Test" description="Verifying functionality of [/PUT:customers/customerId-HTTP-200-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for updateCustomerRecord subflow output of customerRecord property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Update Customer Record Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('updateCustomerRecord')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerRecord" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/put_customers_{customerid}.json').asString()]" doc:name="Set Payload" />
		<set-variable variableName="customerId" value="333" doc:name="customerId" />
		
		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="PUT" path="/customers/#[flowVars['customerId']]" doc:name="PUT HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(200))]" doc:name="assert that - http.status eq 200" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/put_200_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- /PUT CUSTOMER/{CUSTOMERID} TEST Description: Validating the /PUT CUSTOMER/{CUSTOMERID} resource for the HTTP 400 Response. -->
	<munit:test name="/PUT:customers/customerId-HTTP-400-Test" description="Verifying functionality of [/PUT:customers/customerId-HTTP-400-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="false" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/put_customers_{customerid}_invalid.json').asString()]" doc:name="Set Payload" />
		<set-variable variableName="customerId" value="333" doc:name="customerId" />
		<http:request config-ref="HTTP_Request_Configuration" method="PUT" path="/customers/#[flowVars['customerId']]" doc:name="PUT HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="400" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(400))]" doc:name="assert that - http.status eq 400" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/put_400_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- /PUT CUSTOMER/{CUSTOMERID} TEST Description: Validating the /PUT CUSTOMER/{CUSTOMERID} resource for the HTTP 401 Response. -->
	<munit:test name="/PUT:customers/customerId-HTTP-401-Test" description="Verifying functionality of [/PUT:customers/customerId-HTTP-401-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<!-- Setting the validToken to false should trigger an HTTP 401 response -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="false" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/put_customers_{customerid}.json').asString()]" doc:name="Set Payload" />
		<set-variable variableName="customerId" value="333" doc:name="customerId" />
		
		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="PUT" path="/customers/#[flowVars['customerId']]" doc:name="PUT HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="401" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(401))]" doc:name="assert that - http.status eq 401" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/put_401_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>



	<!-- /PUT CUSTOMER/{CUSTOMERID} TEST Description: Validating the /PUT CUSTOMER/{CUSTOMERID} resource for the HTTP 404 Response. -->
	<munit:test name="/PUT:customers/customerId-HTTP-404-Test" description="Verifying functionality of [/PUT:customers/customerId-HTTP-404-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for updateCustomerRecord subflow output of customerRecord property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Update Customer Record Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('updateCustomerRecord')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerRecord" value="#[]" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/put_customers_{customerid}.json').asString()]" doc:name="Set Payload" />
		<set-variable variableName="customerId" value="10000" doc:name="customerId" />
		
		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="PUT" path="/customers/#[flowVars['customerId']]" doc:name="PUT HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="404" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(404))]" doc:name="assert that - http.status eq 404" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/put_404_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- /PUT CUSTOMER/{CUSTOMERID} TEST Description: Validating the /PUT CUSTOMER/{CUSTOMERID} resource for the HTTP 500 Response. -->
	<munit:test name="/PUT:customers/customerId-HTTP-500-Test" description="Verifying functionality of [/PUT:customers/customerId-HTTP-500-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for updateCustomerRecord subflow output of customerRecord property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Update Customer Record Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('updateCustomerRecord')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[('EXCEPTION')]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerRecord" value="#[]" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-payload value="#[getResource('myorganizationapi/samples/customer/input/put_customers_{customerid}.json').asString()]" doc:name="Set Payload" />
		<set-variable variableName="customerId" value="333" doc:name="customerId" />
		
		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="PUT" path="/customers/#[flowVars['customerId']]" doc:name="PUT HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
				<http:header headerName="Content-Type" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="500" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(500))]" doc:name="assert that - http.status eq 500" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/put_500_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>


	<!-- ========================================== -->
	<!-- /DELETE: CUSTOMERS/{CUSTOMERID} TESTS -->
	<!-- ========================================== -->

	<!-- /DELETE CUSTOMER/{CUSTOMERID} TEST Description: Validating the /DELETE CUSTOMER/{CUSTOMERID} resource for the HTTP 204 Response. -->
	<munit:test name="/DELETE:customers/customerId-HTTP-204-Test" description="Verifying functionality of [/DELETE:customers/customerId-HTTP-204-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for deleteCustomerRecord subflow output of customerRecordDeleted property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Delete Customer Record Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('deleteCustomerRecord')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerRecordDeleted" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-variable variableName="customerId" value="333" doc:name="customerId" />
		
		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="DELETE" path="/customers/#[flowVars['customerId']]" doc:name="DELETE HTTP REQUEST" />
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(204))]" doc:name="assert that - http.status eq 204" />
	</munit:test>

	<!-- /DELETE CUSTOMER/{CUSTOMERID} TEST Description: Validating the /DELETE CUSTOMER/{CUSTOMERID} resource for the HTTP 401 Response. -->
	<munit:test name="/DELETE:customers/customerId-HTTP-401-Test" description="Verifying functionality of [/DELETE:customers/customerId-HTTP-401-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="false" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-variable variableName="customerId" value="333" doc:name="customerId" />
		
		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="DELETE" path="/customers/#[flowVars['customerId']]" doc:name="DELETE HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="401" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(401))]" doc:name="assert that - http.status eq 401" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/delete_401_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

	<!-- /DELETE CUSTOMER/{CUSTOMERID} TEST Description: Validating the /DELETE CUSTOMER/{CUSTOMERID} resource for the HTTP 500 Response. -->
	<munit:test name="/DELETE:customers/customerId-HTTP-500-Test" description="Verifying functionality of [/DELETE:customers/customerId-HTTP-500-Test]">

		<!-- Set up mock for commonValidateToken subflow output of validToken property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Token Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateToken')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validToken" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for commonValidateRequest subflow output of validRequest property -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Validate Request Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('commonValidateRequest')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="validRequest" value="true" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>
		<!-- Set up mock for deleteCustomerRecord subflow output of customerRecordDeleted property -->
		<!-- Setting the customerRecordDeleted property to false should return a HTTP 500 -->
		<mock:when messageProcessor="mule:sub-flow" doc:name="Mock Delete Customer Record Sub-Flow">
			<mock:with-attributes>
				<mock:with-attribute name="name" whereValue="#[matchContains('deleteCustomerRecord')]" />
			</mock:with-attributes>
			<mock:then-return payload="#[samePayload()]">
				<mock:invocation-properties>
					<mock:invocation-property key="customerRecordDeleted" value="false" />
				</mock:invocation-properties>
			</mock:then-return>
		</mock:when>

		<set-variable variableName="customerId" value="333" doc:name="customerId" />
		
		<!-- Invoke API using HTTP Request -->
		<http:request config-ref="HTTP_Request_Configuration" method="DELETE" path="/customers/#[flowVars['customerId']]" doc:name="DELETE HTTP REQUEST">
			<http:request-builder>
				<http:header headerName="Accept" value="application/json" />
			</http:request-builder>
			<http:success-status-code-validator values="500" />
		</http:request>
		<object-to-string-transformer doc:name="http response to string" />
		<munit:assert-true message="The HTTP Status code is not correct!" condition="#[messageInboundProperty('http.status').is(eq(500))]" doc:name="assert that - http.status eq 500" />
		<munit:assert-on-equals message="The response payload is not correct!" expectedValue="#[getResource('myorganizationapi/samples/customer/output/delete_500_customers_{customerid}.json').asString()]" actualValue="#[payload]" doc:name="assert that - payload is as expected" />
	</munit:test>

</mule>
